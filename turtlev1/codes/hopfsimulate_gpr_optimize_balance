import time
import numpy as np
import mujoco
import matplotlib.pyplot as plt
from bayes_opt import BayesianOptimization

# =============================================================================
# 1. LOAD MUJOCO MODEL & HELPER FUNCTIONS
# =============================================================================
model_path = (
    "c:/Users/chike/Box/TurtleRobotExperiments/"
    "Sea_Turtle_Robot_AI_Powered_Simulations_Project/NnamdiFiles/mujocotest1/"
    "assets/turtlev1/testrobot1.xml"
)
model = mujoco.MjModel.from_xml_path(model_path)
data = mujoco.MjData(model)

def get_actuator_index(model, name):
    for i in range(model.nu):
        actuator_name = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_ACTUATOR, i)
        if actuator_name == name:
            return i
    raise ValueError(f"Actuator '{name}' not found in model.")

# For cost evaluation, we use the "base" body as our center-of-mass reference.
try:
    main_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, "base")
except Exception:
    main_body_id = 0
total_mass = np.sum(model.body_mass)

# =============================================================================
# 2. HOPF OSCILLATOR DYNAMICS & GAIT CONFIGURATION
# =============================================================================
def hopf_step(x, y, alpha, mu, omega, dt, coupling, xall, yall, index):
    """One Euler integration step for a Hopf oscillator with coupling."""
    r_sq = x*x + y*y
    # Base Hopf dynamics (limit cycle)
    dx = alpha * (mu - r_sq) * x - omega * y
    dy = alpha * (mu - r_sq) * y + omega * x
    # Add linear coupling from other oscillators
    for j in range(len(xall)):
        if j == index:
            continue
        K_ij = coupling[index, j]
        dx += K_ij * (xall[j] - x)
        dy += K_ij * (yall[j] - y)
    x_new = x + dx * dt
    y_new = y + dy * dt
    return x_new, y_new

# List of actuator names (the keys in our oscillator dictionary)
actuator_names = [
    "pos_frontleftflipper",
    "pos_frontrightflipper",
    "pos_backleft",
    "pos_backright",
    "pos_frontlefthip",
    "pos_frontrighthip"
]
actuator_indices = {name: get_actuator_index(model, name) for name in actuator_names}

# Joint limits (from your MJCF)
joint_limits = {
    "pos_frontleftflipper":  (-1.57,  0.64),
    "pos_frontrightflipper": (-0.64,  1.571),
    "pos_backleft":          (-1.571, 0.524),
    "pos_backright":         (-0.524, 1.571),
    "pos_frontlefthip":      (-1.571, 1.22),
    "pos_frontrighthip":     (-1.22,  1.571)
}

# Define a constant coupling matrix for all oscillators using diagonal-forward gait pairing.
num_joints = len(actuator_names)
K = np.zeros((num_joints, num_joints))
in_phase_coupling  = 0.8
out_phase_coupling = -0.8
# (Assign in-phase for joints on the same side and out-of-phase for cross-side pairs.)
left_indices  = [0, 2, 4]  # frontleftflipper, backleft, frontlefthip
right_indices = [1, 3, 5]  # frontrightflipper, backright, frontrighthip
for i in range(num_joints):
    for j in range(num_joints):
        if i == j: continue
        if (i in left_indices and j in left_indices) or (i in right_indices and j in right_indices):
            K[i, j] = in_phase_coupling
        else:
            K[i, j] = out_phase_coupling

# Define phase offsets for diagforward gait.
phase_offsets_diagforward = {
    "pos_frontleftflipper":  -np.pi,
    "pos_frontrightflipper":  0.0,      # opposite phase relative to front left
    "pos_backleft":           0.0,      # in-phase with front right
    "pos_backright":          np.pi,    # opposite phase relative to front right
    "pos_frontlefthip":      -np.pi/2,
    "pos_frontrighthip":      np.pi/2
}

# Mapping parameters from oscillator state (x,y) to joint angles.
joint_output_map = {
    "pos_frontleftflipper":  {"offset": -0.8, "gain": 3.0},
    "pos_frontrightflipper": {"offset":  0.8, "gain": 3.0},
    "pos_backleft":          {"offset": -0.5, "gain": 1.0},
    "pos_backright":         {"offset":  0.5, "gain": 1.0},
    "pos_frontlefthip":      {"offset":  0.3, "gain": -1.0},
    "pos_frontrighthip":     {"offset":  0.3, "gain":  1.0}
}

# Frequency parameters (kept constant here)
stance_freq = 2.0   # rad/s
swing_freq  = 4.0   # rad/s

# =============================================================================
# 3. SIMULATION FUNCTION FOR COST EVALUATION (HEADLESS)
# =============================================================================
def simulate_hopf_cpg(params, sim_duration=30.0, dt=0.001):
    """
    Simulate the Hopf-oscillator CPG for a fixed time and return the cost of transport.
    
    params: [alpha, mu, a_param, in_phase_coupling, out_phase_coupling, stance_freq, swing_freq]
    sim_duration: simulation time in seconds.
    dt: integration time step.
    """
    # Unpack parameters to be optimized.
    alpha_opt, mu_opt, a_param_opt, in_phase_coupling, out_phase_coupling, stance_freq_opt, swing_freq_opt = params
    
    # Reset oscillators (initialize with small random noise)
    oscillators = {}
    for name in actuator_names:
        oscillators[name] = {"x": 0.02 * np.random.randn(), "y": 0.02 * np.random.randn()}
    
    # Reset simulation state by reinitializing data (optional: here we assume data is reusable)
    mujoco.mj_resetData(model, data)
    
    # Set up variables for energy and displacement
    power_consumption = []
    time_steps = int(sim_duration / dt)
    com_positions = []
    
    # Get initial COM position of main body (for displacement)
    init_com = data.xpos[main_body_id].copy()
    
    # Main simulation loop (headless, without viewer)
    for step in range(time_steps):
        # Update Hopf oscillator states using Euler integration
        x_all = [oscillators[name]["x"] for name in actuator_names]
        y_all = [oscillators[name]["y"] for name in actuator_names]
        
        for i, name in enumerate(actuator_names):
            x_i = oscillators[name]["x"]
            y_i = oscillators[name]["y"]
            # Frequency blending: 
            # (Using logistic blending between stance and swing frequencies.)
            freq = (stance_freq_opt / (1.0 + np.exp(-a_param_opt * y_i))) + \
                   (swing_freq_opt  / (1.0 + np.exp(a_param_opt * y_i)))
            x_new, y_new = hopf_step(
                x_i, y_i, alpha_opt, mu_opt, freq, dt,
                K, x_all, y_all, i
            )
            oscillators[name]["x"] = x_new
            oscillators[name]["y"] = y_new

        # Convert oscillator states to joint angles
        for name in actuator_names:
            x_i = oscillators[name]["x"]
            y_i = oscillators[name]["y"]
            delta_phi = phase_offsets_diagforward[name]
            # Rotate the state by the phase offset.
            x_phase = x_i * np.cos(delta_phi) - y_i * np.sin(delta_phi)
            offset = joint_output_map[name]["offset"]
            gain   = joint_output_map[name]["gain"]
            angle_raw = offset + gain * x_phase
            min_angle, max_angle = joint_limits[name]
            angle = np.clip(angle_raw, min_angle, max_angle)
            # Set the control value.
            data.ctrl[get_actuator_index(model, name)] = angle
        
        # Step the simulation.
        mujoco.mj_step(model, data)
        
        # Record instantaneous power: approximate using actuator_force * joint velocity.
        qvel = data.qvel[:model.nu]
        torque = data.actuator_force[:model.nu]
        instant_power = np.sum(torque * qvel)
        power_consumption.append(instant_power)
        
        # Record center-of-mass position.
        com_positions.append(data.xpos[main_body_id].copy())
    
    # Compute total energy consumed (using dt integration)
    total_energy = np.sum(power_consumption) * dt
    # Compute displacement from initial COM position.
    final_com = com_positions[-1]
    displacement = final_com - init_com
    distance_traveled = np.linalg.norm(displacement)
    
    # Avoid division by very small distance (penalize if robot did not move)
    if distance_traveled < 0.01:
        cost = 1e6  # Very high cost if little motion.
    else:
        # Cost of transport: energy per unit weight-distance.
        weight = total_mass * 9.81
        cost = total_energy / (weight * distance_traveled)
    
    return cost

# =============================================================================
# 4. BLACK-BOX FUNCTION & BAYESIAN OPTIMIZATION
# =============================================================================
def cpg_blackbox(alpha_opt, mu_opt, a_param_opt, in_phase_coupling, out_phase_coupling, stance_freq_opt, swing_freq_opt):
    # Bayesian optimization routines maximize the function; we return negative cost.
    params = [alpha_opt, mu_opt, a_param_opt, in_phase_coupling, out_phase_coupling, stance_freq_opt, swing_freq_opt]
    cost = simulate_hopf_cpg(params, sim_duration=30.0, dt=0.001)
    print(f"Tested params: α={alpha_opt:.3f}, μ={mu_opt:.3f}, a={a_param_opt:.3f}, "
          f"couplings: {in_phase_coupling:.3f}, {out_phase_coupling:.3f}, "
          f"freqs: {stance_freq_opt:.3f}, {swing_freq_opt:.3f} -> cost: {cost:.6f}")
    return -cost

# Set parameter bounds (adjust as appropriate)
pbounds = {
    'alpha_opt': (5.0, 20.0),      # Convergence gain
    'mu_opt':    (0.01, 0.1),      # Intrinsic amplitude (mu) (remember amplitude ~ sqrt(mu))
    'a_param_opt': (5.0, 20.0),    # Logistic steepness for frequency blending
    'in_phase_coupling': (0.5, 1.0),
    'out_phase_coupling': (-1.0, -0.5),
    'stance_freq_opt': (1.0, 3.0),  # Frequency bounds for stance
    'swing_freq_opt': (3.0, 6.0)    # Frequency bounds for swing
}

optimizer = BayesianOptimization(
    f=cpg_blackbox,
    pbounds=pbounds,
    verbose=2,
    random_state=42
)

print("Starting Bayesian Optimization for diagforward gait (minimize cost of transport)...")
optimizer.maximize(init_points=5, n_iter=15)

optimal = optimizer.max['params']
print("Optimal parameters found:")
print(optimal)

# =============================================================================
# 5. RUN FINAL SIMULATION WITH OPTIMAL PARAMETERS & PLOT RESULTS
# =============================================================================
opt_params = [
    optimal['alpha_opt'], 
    optimal['mu_opt'], 
    optimal['a_param_opt'],
    optimal['in_phase_coupling'],
    optimal['out_phase_coupling'],
    optimal['stance_freq_opt'],
    optimal['swing_freq_opt']
]
sim_duration = 30.0
dt_sim = 0.001
time_steps = int(sim_duration / dt_sim)
time_vec = np.linspace(0, sim_duration, time_steps)
# We'll record one joint's trajectory (e.g., frontleftflipper) for visualization.
joint_traj = []

# Reset oscillators and simulation for final run.
oscillators = {}
for name in actuator_names:
    oscillators[name] = {"x": 0.02 * np.random.randn(), "y": 0.02 * np.random.randn()}
mujoco.mj_resetData(model, data)

for step in range(time_steps):
    # Integrate oscillators
    x_all = [oscillators[name]["x"] for name in actuator_names]
    y_all = [oscillators[name]["y"] for name in actuator_names]
    for i, name in enumerate(actuator_names):
        x_i = oscillators[name]["x"]
        y_i = oscillators[name]["y"]
        freq = (opt_params[5] / (1.0 + np.exp(-opt_params[2] * y_i))) + \
               (opt_params[6]  / (1.0 + np.exp(opt_params[2] * y_i)))
        x_new, y_new = hopf_step(x_i, y_i, opt_params[0], opt_params[1], freq, dt_sim, K, x_all, y_all, i)
        oscillators[name]["x"] = x_new
        oscillators[name]["y"] = y_new
    # Map oscillator state to joint angles and apply control
    for name in actuator_names:
        x_i = oscillators[name]["x"]
        y_i = oscillators[name]["y"]
        delta_phi = phase_offsets_diagforward[name]
        x_phase = x_i * np.cos(delta_phi) - y_i * np.sin(delta_phi)
        offset = joint_output_map[name]["offset"]
        gain   = joint_output_map[name]["gain"]
        angle = np.clip(offset + gain * x_phase, joint_limits[name][0], joint_limits[name][1])
        data.ctrl[get_actuator_index(model, name)] = angle
        # For visualization, record one joint (e.g., frontleftflipper)
        if name == "pos_frontleftflipper":
            joint_traj.append(angle)
    mujoco.mj_step(model, data)

# Plot results
plt.figure(figsize=(10, 5))
plt.plot(time_vec, joint_traj, label="pos_frontleftflipper")
plt.xlabel("Time (s)")
plt.ylabel("Joint Angle (rad)")
plt.title("Optimized Diagforward Gait: Joint Trajectory")
plt.legend()
plt.grid(True)
plt.show()

# Plot the progress of cost optimization over iterations
iteration_costs = [res['target'] for res in optimizer.res]
plt.figure(figsize=(10, 5))
plt.plot(range(1, len(iteration_costs) + 1), iteration_costs, label="Cost of Transport")
plt.xlabel("Iteration")
plt.ylabel("Negative Cost of Transport")
plt.title("Progress of Cost of Transport Optimization")
plt.legend()
plt.grid(True)
plt.show()
